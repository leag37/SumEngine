//*************************************************************************************************
// Title: SumFloat.inl
// Author: Gael Huber
// Description: Non-vectorized representations of vector quantities. Primarily constructor for
//	passing data to GPU. 
//*************************************************************************************************

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float2::_Float2()
	: x(0.0f), y(0.0f)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float2::_Float2(SFLOAT _x, SFLOAT _y)
	: x(_x), y(_y)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float2::_Float2(const SFLOAT* p)
	: x(p[0]), y(p[1])
{ }

//*************************************************************************************************
// Assignment operator
//*************************************************************************************************
SUMINLINE _Float2& _Float2::operator=(const _Float2& rhs)
{
	x = rhs.x;
	y = rhs.y;
	return *this;
}

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float3::_Float3()
	: x(0.0f), y(0.0f), z(0.0f)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float3::_Float3(SFLOAT _x, SFLOAT _y, SFLOAT _z)
	: x(_x), y(_y), z(_z)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float3::_Float3(const SFLOAT* p)
	: x(p[0]), y(p[1]), z(p[2])
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float3& _Float3::operator=(const _Float3& rhs)
{
	x = rhs.x;
	y = rhs.y;
	z = rhs.z;
	return *this;
}

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float4::_Float4()
	: x(0.0f), y(0.0f), z(0.0f), w(0.0f)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float4::_Float4(SFLOAT _x, SFLOAT _y, SFLOAT _z, SFLOAT _w)
	: x(_x), y(_y), z(_z), w(_w)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float4::_Float4(const SFLOAT* p)
	: x(p[0]), y(p[1]), z(p[2]), w(p[3])
{ }

//*************************************************************************************************
// Assignment
//*************************************************************************************************
SUMINLINE _Float4& _Float4::operator=(const _Float4& rhs)
{
	x = rhs.x;
	y = rhs.y;
	z = rhs.z;
	w = rhs.w;
	return *this;
}

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float3x3::_Float3x3()
	:	_11(0.0f), _12(0.0f), _13(0.0f),
		_21(0.0f), _22(0.0f), _23(0.0f),
		_31(0.0f), _32(0.0f), _33(0.0f)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float3x3::_Float3x3(	
	SFLOAT m11, SFLOAT m12, SFLOAT m13,
	SFLOAT m21, SFLOAT m22, SFLOAT m23,
	SFLOAT m31, SFLOAT m32, SFLOAT m33)
	:	_11(m11), _12(m12), _13(m13),
		_21(m21), _22(m22), _23(m23),
		_31(m31), _32(m32), _33(m33)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float3x3::_Float3x3(const SFLOAT* m)
	:	_11(m[0]), _12(m[1]), _13(m[2]),
		_21(m[3]), _22(m[4]), _23(m[5]),
		_31(m[6]), _32(m[7]), _33(m[8])
{ }

//*************************************************************************************************
// Accessor
//*************************************************************************************************
SUMINLINE SFLOAT _Float3x3::operator() (SUINT row, SUINT column) const
{
	return m[row][column];
}

//*************************************************************************************************
// Accessor
//*************************************************************************************************
SUMINLINE SFLOAT& _Float3x3::operator() (SUINT row, SUINT column)
{
	return m[row][column];
}

//*************************************************************************************************
// Assignment
//*************************************************************************************************
SUMINLINE _Float3x3& _Float3x3::operator=(const _Float3x3& rhs)
{
	_11 = rhs._11; _12 = rhs._12; _13 = rhs._13;
	_21 = rhs._21; _22 = rhs._22; _23 = rhs._23;
	_31 = rhs._31; _32 = rhs._32; _33 = rhs._33;
	return *this;
}

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float4x3::_Float4x3()
	:	_11(0.0f), _12(0.0f), _13(0.0f),
		_21(0.0f), _22(0.0f), _23(0.0f),
		_31(0.0f), _32(0.0f), _33(0.0f),
		_41(0.0f), _42(0.0f), _43(0.0f)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float4x3::_Float4x3(	
	SFLOAT m11, SFLOAT m12, SFLOAT m13,
	SFLOAT m21, SFLOAT m22, SFLOAT m23,
	SFLOAT m31, SFLOAT m32, SFLOAT m33,
	SFLOAT m41, SFLOAT m42, SFLOAT m43)
	:	_11(m11), _12(m12), _13(m13),
		_21(m21), _22(m22), _23(m23),
		_31(m31), _32(m32), _33(m33),
		_41(m41), _42(m42), _43(m43)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float4x3::_Float4x3(const SFLOAT* m)
	:	_11(m[0]), _12(m[1]), _13(m[2]),
		_21(m[3]), _22(m[4]), _23(m[5]),
		_31(m[6]), _32(m[7]), _33(m[8]),
		_41(m[9]), _42(m[10]), _43(m[11])
{ }

//*************************************************************************************************
// Accessor
//*************************************************************************************************
SUMINLINE SFLOAT _Float4x3::operator() (SUINT row, SUINT column) const
{
	return m[row][column];
}

//*************************************************************************************************
// Accessor
//*************************************************************************************************
SUMINLINE SFLOAT& _Float4x3::operator() (SUINT row, SUINT column)
{
	return m[row][column];
}

//*************************************************************************************************
// Assignment
//*************************************************************************************************
SUMINLINE _Float4x3& _Float4x3::operator=(const _Float4x3& rhs)
{
	_11 = rhs._11; _12 = rhs._12; _13 = rhs._13;
	_21 = rhs._21; _22 = rhs._22; _23 = rhs._23;
	_31 = rhs._31; _32 = rhs._32; _33 = rhs._33;
	_41 = rhs._41; _42 = rhs._42; _43 = rhs._43;
	return *this;
}

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float4x4::_Float4x4()
	:	_11(0.0f), _12(0.0f), _13(0.0f), _14(0.0f),
		_21(0.0f), _22(0.0f), _23(0.0f), _24(0.0f),
		_31(0.0f), _32(0.0f), _33(0.0f), _34(0.0f),
		_41(0.0f), _42(0.0f), _43(0.0f), _44(0.0f)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float4x4::_Float4x4(	
	SFLOAT m11, SFLOAT m12, SFLOAT m13, SFLOAT m14,
	SFLOAT m21, SFLOAT m22, SFLOAT m23, SFLOAT m24,
	SFLOAT m31, SFLOAT m32, SFLOAT m33, SFLOAT m34,
	SFLOAT m41, SFLOAT m42, SFLOAT m43, SFLOAT m44)
	:	_11(m11), _12(m12), _13(m13), _14(m14),
		_21(m21), _22(m22), _23(m23), _24(m24),
		_31(m31), _32(m32), _33(m33), _34(m34),
		_41(m41), _42(m42), _43(m43), _44(m44)
{ }

//*************************************************************************************************
// Constructor
//*************************************************************************************************
SUMINLINE _Float4x4::_Float4x4(const SFLOAT* m)
	:	_11(m[0]), _12(m[1]), _13(m[2]), _14(m[3]),
		_21(m[4]), _22(m[5]), _23(m[6]), _24(m[7]),
		_31(m[8]), _32(m[9]), _33(m[10]), _34(m[11]),
		_41(m[12]), _42(m[13]), _43(m[14]), _44(m[15])
{ }

//*************************************************************************************************
// Accessor
//*************************************************************************************************
SUMINLINE SFLOAT _Float4x4::operator() (SUINT row, SUINT column) const
{
	return m[row][column];
}

//*************************************************************************************************
// Accessor
//*************************************************************************************************
SUMINLINE SFLOAT& _Float4x4::operator() (SUINT row, SUINT column)
{
	return m[row][column];
}

//*************************************************************************************************
// Assignment
//*************************************************************************************************
SUMINLINE _Float4x4& _Float4x4::operator=(const _Float4x4& rhs)
{
	_11 = rhs._11; _12 = rhs._12; _13 = rhs._13; _14 = rhs._14;
	_21 = rhs._21; _22 = rhs._22; _23 = rhs._23; _24 = rhs._24;
	_31 = rhs._31; _32 = rhs._32; _33 = rhs._33; _34 = rhs._34;
	_41 = rhs._41; _42 = rhs._42; _43 = rhs._43; _44 = rhs._44;
	return *this;
}

//*************************************************************************************************
// Load a Float2 into a vector
//*************************************************************************************************
SUMINLINE Vector LoadFloat2(const Float2* source)
{
#ifdef SUMSIMD
	Vector x = _mm_load_ss(&source->x);
	Vector y = _mm_load_ss(&source->y);
	return _mm_unpacklo_ps(x, y);
#else
#endif
}

//*************************************************************************************************
// Load a Float3 into a vector
//*************************************************************************************************
SUMINLINE Vector LoadFloat3(const Float3* source)
{
#ifdef SUMSIMD
	Vector x = _mm_load_ss(&source->x);
	Vector y = _mm_load_ss(&source->y);
	Vector z = _mm_load_ss(&source->z);
	Vector xy = _mm_unpacklo_ps(x, y);
	return _mm_movelh_ps(xy, z);
#else
#endif
}

//*************************************************************************************************
// Load a Float4 into a vector
//*************************************************************************************************
SUMINLINE Vector LoadFloat4(const Float4* source)
{
#ifdef SUMSIMD
	return _mm_loadu_ps(&source->x);
#else
#endif
}

//*************************************************************************************************
// Load a Float3x3 into a matrix
//
// [a b c]
// [d e f]
// [g h i]
//
// Want:
// [a b c 0]
// [d e f 0]
// [g h i 0]
// [0 0 0 1]
//
// Load entire contents into 3 vectors
// v1 = [a b c d]
// v2 = [e f g h]
// v3 = [i 0 0 0]
//
// Save zero for proper unpacking
// z = [0 0 0 0]
//
// FORMAT NEEDED
// t1 = _mm_unpackhi_ps(v2, z) => [g h 0 0]
// t2 = _mm_unpacklo_ps(v1, z) => [a b 0 0]
// t3 = _mm_unpackhi_ps(v1, z) => [c d 0 0]
// t4 = _mm_shuffle_ps(t3, v2, _MM_SHUFFLE(0, 0, 1, 1)) => [d d e e]
// t5 = _mm_shuffle_ps(v2, v3, _MM_SHUFFLE(1, 1, 1, 1) => [f f 0 0] 
//
// m.r[0] = _mm_shuffle_ps(t2, t3, _MM_SHUFFLE(3, 0, 1, 0)) => [a b c 0]
// m.r[1] = _mm_shuffle_ps(t4, t5, _MM_SHUFFLE(3, 1, 3, 1)) => [d e f 0]
// m.r[2] = _mm_unpacklo_ps(t1, v3) => [g h i 0]
// m.r[3] = gVIdentityR3
//*************************************************************************************************
SUMINLINE Matrix LoadFloat3x3(const Float3x3* source)
{
#ifdef SUMSIMD
	// Load the entire contents of the matrix into 3 vectors
	Vector v1 = _mm_loadu_ps(&source->m[0][0]);
	Vector v2 = _mm_loadu_ps(&source->m[1][1]);
	Vector v3 = _mm_load_ss(&source->m[2][2]);

	// Grab a zero vector to ensure data can be unpacked properly
	Vector z = _mm_setzero_ps();

	// Unpack into a set of temporary vectors used to create matrix
	Vector t1 = _mm_unpackhi_ps(v2, z);
	Vector t2 = _mm_unpacklo_ps(v1, z);
	Vector t3 = _mm_unpackhi_ps(v1, z);
	Vector t4 = _mm_shuffle_ps(t3, v2, _MM_SHUFFLE(0, 0, 1, 1));
	Vector t5 = _mm_shuffle_ps(v2, v3, _MM_SHUFFLE(1, 1, 1, 1));

	// Create matrix
	Matrix m;
	m.r[0] = _mm_shuffle_ps(t2, t3, _MM_SHUFFLE(3, 0, 1, 0));
	m.r[1] = _mm_shuffle_ps(t4, t5, _MM_SHUFFLE(3, 1, 3, 1));
	m.r[2] = _mm_unpacklo_ps(t1, v3);
	m.r[3] = gVIdentityR3;
	return m;
#else
#endif
}

//*************************************************************************************************
//
//*************************************************************************************************
//Matrix LoadFloat4x3(const Float4x3* source);

//*************************************************************************************************
// Load a Float4x4 into a destination matrix
//*************************************************************************************************
SUMINLINE Matrix LoadFloat4x4(const Float4x4* source)
{
	Matrix m;
	m.r[0] = _mm_loadu_ps(source->m[0]);
	m.r[1] = _mm_loadu_ps(source->m[1]);
	m.r[2] = _mm_loadu_ps(source->m[2]);
	m.r[3] = _mm_loadu_ps(source->m[3]);
	return m;
}

//*************************************************************************************************
// Store a Vector into a Float2
//*************************************************************************************************
SUMINLINE void StoreFloat2(Float2* destination, const Vector v)
{
	Vector vTemp = _mm_shuffle_ps(v, v, _MM_SHUFFLE(1, 1, 1, 1));
	_mm_store_ss(&destination->x, v);
	_mm_store_ss(&destination->y, vTemp);
}

//*************************************************************************************************
// Store a vector into a Float3
//*************************************************************************************************
SUMINLINE void StoreFloat3(Float3* destination, const Vector v)
{
	Vector vTemp1 = _mm_shuffle_ps(v, v, _MM_SHUFFLE(1, 1, 1, 1));
	Vector vTemp2 = _mm_shuffle_ps(v, v, _MM_SHUFFLE(2, 2, 2, 2));
	_mm_store_ss(&destination->x, v);
	_mm_store_ss(&destination->y, vTemp1);
	_mm_store_ss(&destination->z, vTemp2);
}

//*************************************************************************************************
// Store a vector into a Float4
//*************************************************************************************************
SUMINLINE void StoreFloat4(Float4* destination, const Vector v)
{
	_mm_storeu_ps(&destination->x, v);
}

//*************************************************************************************************
//
//*************************************************************************************************
//void StoreFloat3x3(Float3x3* destination, const Matrix& m);

//*************************************************************************************************
//
//*************************************************************************************************
//void StoreFloat4x3(Float4x3* destination, const Matrix& m);

//*************************************************************************************************
// Store a Matrix into a Float4x4
//*************************************************************************************************
SUMINLINE void StoreFloat4x4(Float4x4* destination, const Matrix& m)
{
	_mm_storeu_ps(destination->m[0], m.r[0]);
	_mm_storeu_ps(destination->m[1], m.r[1]);
	_mm_storeu_ps(destination->m[2], m.r[2]);
	_mm_storeu_ps(destination->m[3], m.r[3]);
}
